# **Liskov Substitution Principle (리스코프 치환 원칙)**

## 1-1. 리스코프 치환 원칙이란?

> 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 합니다.

- 자식 클래스는 부모 클래스의 타입 정의를 어기지 않아야 합니다. 

- 다시 말해 부모객체와 자식 객체가 있다고 가정할 때, 자식은 당연히 부모 객체로 치환할 수 있어야 합니다. 

## 1-2. 사용 예제

### 위반  사례

- 아버지를 상위 클래스로 하는 딸이라는 하위 클래스가 있다고 합시다. 

- 바로 이것은 전형적인 계층도 형태이며, 객체 지향의 상속을 잘못 적용한 예입니다. 

- 상위 클래스의 객체 참조 변수에는 하위 클래스의 인스턴스를 할당 할 수 있습니다.

```kotlin
val 춘향이 : 아버지 = 딸()
```

위의 코드에서 이상한 점을 찾아보겠습니다. 

- 딸이라는 역할을 가진 춘향이 까지는 굉장히 좋습니다. 

- 하지만 딸인 춘향이가 아버지의 역할까지 가지게 됩니다. 

![위반 사례](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F23236B3E5698577D0ADB64)

### 적용 사례

이번에는 동물 클래스와 이를 상속하는 펭귄 클래스가 있다고 가정하겠습니다. 

```kotlin
val 뽀로로 : 동물 = 펭귄()
```

- 위의 코드는 말 그대로 뽀로로라는 이름을 가진 펭귄이 있습니다. 

- 근데 여기서 이 펭귄은 동물의 행위(메서드)를 하게 하는데 전혀 이상함이 없습니다. 

![적용사레](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2730AF3E5698577E343B8D)


## 정리

즉, 아버지-딸 구조(계층도/조직도)는 리스코프 치환 원칙을 위배하고 있는 것이며, 동물-펭귄 구조(분류도)는 리스코프 치환 원칙을 만족하는 것입니다.

**리스코프 치환 원칙은 객체지향의** `상속`**이라는 특성을 올바르게 활용하면 자연스럽게 얻게 되는 것입니다.**

---

출처: https://server-engineer.tistory.com/226?category=643527 

